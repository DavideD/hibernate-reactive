// Optional: We configure the repositories to ease development and CI builds
buildscript {
    repositories {
        // Optional: Enables the maven local repository
        // Example: ./gradlew build -PenableMavenLocalRepo
        if ( project.hasProperty( 'enableMavenLocalRepo' ) ) {
            // Useful for local development, it should be disabled otherwise
            mavenLocal()
        }
        // Optional: Enables snapshots repository
        // Example: ./gradlew build -PenableCentralSonatypeSnapshotsRep
        if ( project.hasProperty('enableCentralSonatypeSnapshotsRep') ) {
            maven { url 'https://central.sonatype.com/repository/maven-snapshots/' }
        }
        mavenCentral()
    }
}

plugins {
    // Optional: Hibernate Gradle plugin to enable bytecode enhancements
    alias(libs.plugins.org.hibernate.orm)
}

description = 'Hibernate Reactive native SQL Example'

dependencies {
    implementation project( ':hibernate-reactive-core' )

    // Hibernate Validator (optional)
    implementation(libs.org.hibernate.validator.hibernate.validator)
    runtimeOnly(libs.org.glassfish.expressly.expressly)

    // JPA metamodel generation for criteria queries (optional)
    annotationProcessor(libs.org.hibernate.orm.hibernate.jpamodelgen)

    // database driver for PostgreSQL
    runtimeOnly(libs.io.vertx.vertx.pg.client)

    // logging (optional)
    runtimeOnly(libs.org.apache.logging.log4j.log4j.core)

    // Allow authentication to PostgreSQL using SCRAM:
    runtimeOnly(libs.com.ongres.scram.scram.client)
}

// Optional: enable the bytecode enhancements
hibernate { enhancement }

// Create tasks to run the different API available.
//
// They require the selected db ready to accept connections.
//
// Examples, in the native-sql-example folder:
// gradle runExampleOnPostgreSQLMain runExampleOnPostgreSQLMutinyMain
def mainJavaClasses = ['Main', 'MutinyMain']
def dbs = ['PostgreSQL']
mainJavaClasses.each { String mainJavaClass ->
    dbs.each { String db ->
        tasks.register( "runExampleOn${db}${mainJavaClass}", JavaExec ) {
            description = "Run ${mainJavaClass} on ${db}"
            classpath = sourceSets.main.runtimeClasspath
            mainClass = "org.hibernate.reactive.example.nativesql.${mainJavaClass}"
            // The persistence unit name defined in resources/META-INF/persistence.xml
            args db.toLowerCase() + '-example'
        }
    }
}

tasks.register( "runAllExamplesOnPostgreSQL" ) {
    dependsOn = mainJavaClasses.collect( [] as HashSet ) { mainClass -> "runExampleOnPostgreSQL${mainClass}" }
    description = "Run ${mainJavaClasses} on PostgreSQL"
}

tasks.register( "runAllExamples" ) {
    dependsOn = ["runAllExamplesOnPostgreSQL"]
    description = "Run all examples on ${dbs}"
}

// Optional: Task to print the resolved versions of Hibernate ORM and Vert.x
tasks.register( "printResolvedVersions" ) {
    description = "Print the resolved hibernate-orm-core and vert.x versions"
    doLast {
        def hibernateCoreVersion = "n/a"
        def vertxVersion = "n/a"

        // Resolve Hibernate Core and Vert.x versions from compile classpath
        configurations.compileClasspath.resolvedConfiguration.resolvedArtifacts.each { artifact ->
            if (artifact.moduleVersion.id.name == 'hibernate-core') {
                hibernateCoreVersion = artifact.moduleVersion.id.version
            }
            if (artifact.moduleVersion.id.group == 'io.vertx' && artifact.moduleVersion.id.name == 'vertx-sql-client') {
                vertxVersion = artifact.moduleVersion.id.version
            }
        }

        // Print the resolved versions
        println "Resolved Hibernate ORM Core Version: ${hibernateCoreVersion}"
        println "Resolved Vert.x SQL client Version: ${vertxVersion}"
    }
}

// Make the version printing task run before tests and JavaExec tasks
tasks.withType( Test ).configureEach {
    dependsOn printResolvedVersions
}

tasks.withType( JavaExec ).configureEach {
    dependsOn printResolvedVersions
}

